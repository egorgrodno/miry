package main

import (
	"fmt"
	"io"
	"log"
	"os"
	"strings"
	"time"
)

func backupOutput() {
	sourceFileStat, err := os.Stat(outputAbs)
	if err != nil {
		if os.IsNotExist(err) {
			return
		}

		log.Fatal(err)
	} else {
		if !sourceFileStat.Mode().IsRegular() {
			log.Fatal(fmt.Errorf("%s is not a regular file", outputAbs))
		}
	}

	source, err := os.Open(outputAbs)
	assertNoErr(err)
	defer func() {
		assertNoErr(source.Close())
	}()

	destination, err := os.Create(fmt.Sprintf("%s.backup", outputAbs))
	assertNoErr(err)
	defer func() {
		assertNoErr(destination.Close())
	}()
	_, err = io.Copy(destination, source)
}

func writeMirrorlist(mirrors *[]Mirror) {
	content := makeMirrorlistContent(mirrors)
	file, err := os.Create(outputAbs)
	assertNoErr(err)
	defer func() {
		assertNoErr(file.Close())
	}()
	_, err = file.Write(content)
	assertNoErr(err)
}

func makeMirrorlistContent(mirrors *[]Mirror) []byte {
	result := "### Generated by Miry ###\n\n"
	result += fmt.Sprintf("# Cmd:  %s\n", strings.Join(os.Args, " "))
	result += fmt.Sprintf("# When: %s\n\n", time.Now().Format("2006-01-02T15:04:05"))

	for _, m := range *mirrors {
		if m.Rating < 0 {
			break
		}

		result += fmt.Sprintf("Server = %s$repo/os/$arch\n", m.Url)
	}

	return []byte(result)
}
